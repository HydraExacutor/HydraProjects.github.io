<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Trombone Champ Save Editor</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 600px;
    margin: 2rem auto;
    padding: 0 1rem;
    background: #f4f6f8;
    color: #222;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
  }
  label {
    font-weight: bold;
    display: block;
    margin: 1rem 0 0.5rem;
  }
  input[type="file"] {
    margin-bottom: 1rem;
  }
  .toggle-group {
    margin: 1rem 0;
    text-align: center;
  }
  .toggle-group label {
    margin: 0 1rem;
    font-weight: normal;
    cursor: pointer;
  }
  input[type=range] {
    width: 100%;
    margin: 0.5rem 0 1rem;
  }
  input[type=number] {
    width: 100%;
    padding: 0.3rem;
    font-size: 1rem;
    box-sizing: border-box;
  }
  button {
    display: block;
    width: 100%;
    background: #4a90e2;
    border: none;
    color: white;
    font-weight: bold;
    padding: 0.75rem;
    cursor: pointer;
    border-radius: 5px;
    font-size: 1.1rem;
  }
  button:disabled {
    background: #999;
    cursor: not-allowed;
  }
  #message {
    margin-top: 1rem;
    text-align: center;
    font-weight: bold;
  }
</style>
</head>
<body>

<h1>Trombone Champ Save Editor</h1>

<label for="fileInput">Upload your save file (.dat):</label>
<input type="file" id="fileInput" accept=".dat" />

<div class="toggle-group">
  <label>
    <input type="radio" name="editType" value="toots" checked /> Edit Toots
  </label>
  <label>
    <input type="radio" name="editType" value="turds" /> Edit Turds
  </label>
</div>

<label for="currentValue">Current Value Detected:</label>
<input type="number" id="currentValue" readonly />

<label for="newValueSlider">Set New Value:</label>
<input type="range" id="newValueSlider" min="0" max="4294967295" value="0" step="1" />

<label for="newValueInput">Or Enter New Value (0 to 4,294,967,295):</label>
<input type="number" id="newValueInput" min="0" max="4294967295" value="0" step="1" />

<button id="saveBtn" disabled>Download Edited Save</button>

<div id="message"></div>

<script>
  const fileInput = document.getElementById('fileInput');
  const currentValueInput = document.getElementById('currentValue');
  const newValueSlider = document.getElementById('newValueSlider');
  const newValueInput = document.getElementById('newValueInput');
  const saveBtn = document.getElementById('saveBtn');
  const message = document.getElementById('message');
  const editTypeRadios = document.getElementsByName('editType');

  let originalFile;
  let fileBuffer;
  let fileName;
  let currentValueOffset = null;

  // The known markers (little endian hex) for Toots and Turds in save file (4 bytes):
  // You might need to update these offsets if the save format changes.
  // For now, these are the byte sequences just before the 4-byte integer value:
  const MARKERS = {
    toots: '63757272656e63795f746f6f7473', // "currency_toots" hex
    turds: '63757272656e63795f7475726473'  // "currency_turds" hex
  };

  // Utility to convert string hex to Uint8Array
  function hexStringToBytes(hex) {
    const bytes = new Uint8Array(hex.length / 2);
    for(let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(hex.substr(i*2, 2), 16);
    }
    return bytes;
  }

  // Utility: read 4-byte LE uint from DataView at offset
  function readUInt32LE(dataView, offset) {
    return dataView.getUint32(offset, true);
  }
  // Utility: write 4-byte LE uint to DataView at offset
  function writeUInt32LE(dataView, offset, value) {
    dataView.setUint32(offset, value, true);
  }

  // Search for marker in array buffer, return offset of value (marker length + marker offset)
  function findValueOffset(buffer, markerHex) {
    const markerBytes = hexStringToBytes(markerHex);
    const data = new Uint8Array(buffer);
    for(let i=0; i < data.length - markerBytes.length - 4; i++) {
      let found = true;
      for(let j=0; j < markerBytes.length; j++) {
        if(data[i+j] !== markerBytes[j]) {
          found = false;
          break;
        }
      }
      if(found) {
        // value expected to be 4 bytes after marker end
        return i + markerBytes.length;
      }
    }
    return null;
  }

  // When file is loaded, parse it and find current values
  fileInput.addEventListener('change', e => {
    message.textContent = '';
    currentValueInput.value = '';
    newValueSlider.value = 0;
    newValueInput.value = 0;
    saveBtn.disabled = true;
    currentValueOffset = null;

    const file = e.target.files[0];
    if(!file) return;
    fileName = file.name;

    const reader = new FileReader();
    reader.onload = function(ev) {
      fileBuffer = ev.target.result;
      const editType = getSelectedEditType();
      const offset = findValueOffset(fileBuffer, MARKERS[editType]);

      if(offset === null) {
        message.textContent = `Could not find ${editType} value in save file.`;
        currentValueOffset = null;
        currentValueInput.value = '';
        saveBtn.disabled = true;
        return;
      }

      currentValueOffset = offset;
      const dataView = new DataView(fileBuffer);
      const currentVal = readUInt32LE(dataView, offset);
      currentValueInput.value = currentVal;
      newValueSlider.max = 4294967295;
      newValueSlider.value = currentVal;
      newValueInput.max = 4294967295;
      newValueInput.value = currentVal;
      saveBtn.disabled = false;
      message.textContent = `Loaded save file: ${fileName}`;
    }
    reader.readAsArrayBuffer(file);
    originalFile = file;
  });

  // Sync slider and number input
  newValueSlider.addEventListener('input', () => {
    newValueInput.value = newValueSlider.value;
  });
  newValueInput.addEventListener('input', () => {
    let val = parseInt(newValueInput.value);
    if(isNaN(val) || val < 0) val = 0;
    if(val > 4294967295) val = 4294967295;
    newValueInput.value = val;
    newValueSlider.value = val;
  });

  // When edit type changes, reload current value from fileBuffer
  for(let radio of editTypeRadios) {
    radio.addEventListener('change', () => {
      if(!fileBuffer) return;
      const editType = getSelectedEditType();
      const offset = findValueOffset(fileBuffer, MARKERS[editType]);
      if(offset === null) {
        message.textContent = `Could not find ${editType} value in save file.`;
        currentValueOffset = null;
        currentValueInput.value = '';
        saveBtn.disabled = true;
        return;
      }
      currentValueOffset = offset;
      const dataView = new DataView(fileBuffer);
      const currentVal = readUInt32LE(dataView, offset);
      currentValueInput.value = currentVal;
      newValueSlider.value = currentVal;
      newValueInput.value = currentVal;
      saveBtn.disabled = false;
      message.textContent = `Editing ${editType}`;
    });
  }

  function getSelectedEditType() {
    for(let radio of editTypeRadios) {
      if(radio.checked) return radio.value;
    }
    return 'toots'; // default
  }

  // When save button clicked, patch and download new file
  saveBtn.addEventListener('click', () => {
    if(currentValueOffset === null || !fileBuffer) {
      alert('No valid value to edit.');
      return;
    }
    const newVal = parseInt(newValueInput.value);
    if(isNaN(newVal) || newVal < 0 || newVal > 4294967295) {
      alert('Please enter a valid value between 0 and 4,294,967,295.');
      return;
    }

    // Patch the buffer
    const dataView = new DataView(fileBuffer);
    writeUInt32LE(dataView, currentValueOffset, newVal);

    // Save file with original name
    const blob = new Blob([fileBuffer], {type: 'application/octet-stream'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    message.textContent = `Saved file with new value ${newVal}.`;
  });
</script>

</body>
</html>
